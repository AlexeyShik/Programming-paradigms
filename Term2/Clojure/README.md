### [Linear algebra](https://github.com/AlexeyShik/Programming-paradigms/blob/master/Term2/Clojure/linear.clj)  
***Задание:***  
 1. Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:  
      - скаляры – числа  
      - векторы – векторы чисел;  
      - матрицы – векторы векторов чисел.  
 2. Функции над векторами:  
      - `v+`/`v-`/`v*` – покоординатное сложение/вычитание/умножение;  
      - `scalar`/`vect` – скалярное/векторное произведение;  
      - `v*s` – умножение на скаляр.  
 3. Функции над матрицами:  
      - `m+`/`m-`/`m*` – поэлементное сложение/вычитание/умножение;  
      - `m*s` – умножение на скаляр;  
      - `m*v` – умножение на вектор;  
      - `m*m` – матричное умножение;  
      - `transpose` – траспонирование;  
 4. **Сложный вариант**.  
      - Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.  
      - Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть равно `[9 12]`.  
 5. При выполнение задания следует обратить внимание на:  
      - Применение функций высшего порядка.  
      - Выделение общего кода для операций.  
 ### [Functional expressions](https://github.com/AlexeyShik/Programming-paradigms/blob/master/Term2/Clojure/expression.clj)  
 ***Задание:***  
 1. Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений.  
 - Пример описания выражения `2x-3`:  
```  
(def expr
  (subtract
    (multiply
      (constant 2)
      (variable "x"))
    (constant 3)))
```  
 - Выражение должно быть функцией, возвращающей значение выражение при подстановке элементов, заданных отображением. Например, `(expr {"x" 2})` должно быть равно `1`.    
 2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме.  
 Например, `(parseFunction "(- (* 2 x) 3)")` должно быть эквивалентно `expr`.  
 3. **Сложный вариант**. Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для \+, \-, \*.  
 4. При выполнение задания следует обратить внимание на выделение общего кода для операций.  
 ### [Object expressions](https://github.com/AlexeyShik/Programming-paradigms/blob/master/Term2/Clojure/expression.clj)  
 ***Задание:***  
 1. Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной.  
 - Пример описания выражения `2x-3`:  
```
(def expr
  (Subtract
    (Multiply
      (Constant 2)
      (Variable "x"))
    (Const 3)))
```             
 - Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно `1`.  
 - Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.  
 - Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,  
`(parseObject "(- (* 2 x) 3)")`  
должно быть эквивалентно `expr`.  
 - Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))` и  
```  
(Subtract
  (Add
    (Multiply (Const 0) (Variable "x"))
    (Multiply (Const 2) (Const 1)))
  (Const 0))
```                 
так же будут считаться правильным ответом.  
 2. **Сложный вариант**. Констуркторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для \+, \-, \*, \/.  
 3. При выполнение задания можно использовать любой способ преставления объектов.  
 ### [Combinator parser](https://github.com/AlexeyShik/Programming-paradigms/blob/master/Term2/Clojure/expression.clj)  
 ***Задание:***  
  1. Простой вариант. Реализуйте функцию `(parseObjectSuffix "expression")`, разбирающую выражения, записанные в суффиксной форме, и функцию `toStringSuffix`, возвращающую строковое представление выражения в этой форме. Например,  
`(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))`  
должно возвращать `((2 x *) 3 -)`.  
 2. **Сложный вариант**. Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в инфиксной форме, и функцию `toStringInfix`, возвращающую строковое представление выражения в этой форме. Например,  
`(toStringInfix (parseObjectInfix "2 * x - 3"))`  
должно возвращать `((2 * x) - 3)`.  
 3. Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.
